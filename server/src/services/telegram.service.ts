import TelegramBot from 'node-telegram-bot-api';
import type { Message, InlineKeyboardMarkup, ReplyKeyboardMarkup } from 'node-telegram-bot-api';
import { env } from '../config/env';
import { authService } from '../features/auth/services/auth.service';
import type { SignupDto } from '../features/auth/types/auth.types';
import type { IUser } from '../features/users/models/user.model';
import { User } from '../features/users/models/user.model';

class TelegramService {
  private bot: TelegramBot | null = null;
  private isPolling: boolean = false;
  private readonly defaultWebAppText = 'OPEN';

  private getAppBaseUrl(): string {
    return env.APP_URL?.trim() || 'https://upgrace.in';
  }

  private getChatId(msg: Message): number {
    console.log('üîç [TELEGRAM] Getting chat ID:', msg.chat.id);
    console.log('üîç [TELEGRAM] Message:', msg);
    const chatId = msg.chat.id;
    return typeof chatId === 'number' ? chatId : Number(chatId);
  }

  private async syncTelegramProfile(
    user: IUser,
    profile: SignupDto,
  ): Promise<IUser> {
    const updates: Partial<IUser> = {};

    if (profile.telegramFirstName && profile.telegramFirstName !== user.telegramFirstName) {
      updates.telegramFirstName = profile.telegramFirstName;
    }

    if (profile.telegramLastName && profile.telegramLastName !== user.telegramLastName) {
      updates.telegramLastName = profile.telegramLastName;
    }

    if (profile.telegramUsername && profile.telegramUsername !== user.telegramUsername) {
      updates.telegramUsername = profile.telegramUsername;
    }

    const isAutoGeneratedName =
      user.name?.startsWith('AI Earn User') ||
      user.name?.startsWith('AI Earn Bot User');

    if (
      profile.name &&
      profile.name.trim().length > 0 &&
      (isAutoGeneratedName || !user.name || user.name.trim().length === 0)
    ) {
      updates.name = profile.name.trim();
    }

    if (Object.keys(updates).length > 0) {
      console.log('üìù [TELEGRAM] Syncing Telegram profile fields to user document', {
        userId: user._id,
        chatId: user.telegramChatId,
        updates,
      });
      await User.updateOne({ _id: user._id }, { $set: updates });
      Object.assign(user, updates);
    }

    return user;
  }

  private buildLaunchKeyboard(url: string): InlineKeyboardMarkup {
    return {
      inline_keyboard: [
        [
          {
            text: 'Launch Web App',
            web_app: { url },
          },
        ],
      ],
    };
  }

  private buildLaunchReplyKeyboard(): ReplyKeyboardMarkup {
    return {
      keyboard: [
        [
          {
            text: 'launch',
          },
        ],
      ],
      resize_keyboard: true,
      one_time_keyboard: false,
      input_field_placeholder: 'Tap launch or type a command',
    };
  }

  private ensureHttps(originalUrl: string): string {
    if (!originalUrl) {
      return originalUrl;
    }

    try {
      const parsed = new URL(
        originalUrl.startsWith('http') ? originalUrl : `https://${originalUrl}`,
      );

      if (parsed.protocol !== 'https:') {
        parsed.protocol = 'https:';
        const httpsUrl = parsed.toString();
        console.warn('‚ö†Ô∏è [TELEGRAM] Upgrading URL to HTTPS for Telegram requirements', {
          originalUrl,
          httpsUrl,
        });
        return httpsUrl;
      }

      return parsed.toString();
    } catch {
      if (originalUrl.startsWith('http://')) {
        const httpsUrl = `https://${originalUrl.slice('http://'.length)}`;
        console.warn('‚ö†Ô∏è [TELEGRAM] Converted http URL to https', { originalUrl, httpsUrl });
        return httpsUrl;
      }

      if (!originalUrl.startsWith('https://')) {
        const httpsUrl = `https://${originalUrl}`;
        console.warn('‚ö†Ô∏è [TELEGRAM] Prefixed URL with https://', { originalUrl, httpsUrl });
        return httpsUrl;
      }

      return originalUrl;
    }
  }

  private async sendLaunchReplyKeyboard(chatId: number): Promise<void> {
    if (!this.bot) return;
    try {
      await this.bot.sendMessage(
        chatId,
        '‚å®Ô∏è Launch button added at the bottom keyboard.',
        {
          reply_markup: this.buildLaunchReplyKeyboard(),
        },
      );
    } catch (error: any) {
      console.warn('‚ö†Ô∏è [TELEGRAM] Failed to send launch reply keyboard:', error.message || error);
    }
  }

  private buildLoginUrl(chatId: number, token: string): string {
    const baseUrl = this.getAppBaseUrl();
    console.log(`üîó [TELEGRAM] Preparing login URL`, {
      chatId,
      baseUrl,
    });
    const params = new URLSearchParams({
      chatId: String(chatId),
      token,
      source: 'telegram',
    });

    try {
      const url = new URL(baseUrl);
      params.forEach((value, key) => url.searchParams.set(key, value));
      url.searchParams.set('ts', Date.now().toString());
      return this.ensureHttps(url.toString());
    } catch {
      const separator = baseUrl.includes('?') ? '&' : '?';
      params.set('ts', Date.now().toString());
      return this.ensureHttps(`${baseUrl}${separator}${params.toString()}`);
    }
  }

  private extractSignupPayload(msg: Message): SignupDto {
    const chatId = this.getChatId(msg);
    const from = msg.from;
    const firstName = from?.first_name?.trim();
    const lastName = from?.last_name?.trim();
    const username = from?.username?.trim();

    const fallbackNameParts = [firstName, lastName].filter(Boolean);
    const fallbackName =
      fallbackNameParts.join(' ').trim() || username || `AI Earn User ${chatId}`;

    return {
      telegramChatId: chatId,
      telegramUsername: username,
      telegramFirstName: firstName,
      telegramLastName: lastName,
      name: fallbackName,
    };
  }

  private async ensureUserAndToken(msg: Message): Promise<{
    user: IUser;
    token: string;
    isNew: boolean;
  }> {
    const signupPayload = this.extractSignupPayload(msg);
    const chatId = signupPayload.telegramChatId;
    console.log('üë§ [TELEGRAM][AUTH] ensureUserAndToken invoked', {
      chatId,
      username: signupPayload.telegramUsername,
      firstName: signupPayload.telegramFirstName,
    });

    try {
      console.log('üîç [TELEGRAM][AUTH] Attempting login for chatId', chatId);
      const existingUser = await authService.login({ telegramChatId: chatId });
      if (existingUser) {
        await this.syncTelegramProfile(existingUser, signupPayload);
        console.log('‚úÖ [TELEGRAM][AUTH] Existing user logged in', {
          chatId,
          userId: existingUser._id,
        });
        const token = authService.generateToken(existingUser);
        return { user: existingUser, token, isNew: false };
      }
    } catch (error: any) {
      if (error.message?.toLowerCase().includes('inactive')) {
        throw error;
      }
      console.warn(
        '‚ö†Ô∏è [TELEGRAM] Login attempt failed while ensuring user, will try signup:',
        error.message || error,
      );
    }

    try {
      console.log('üÜï [TELEGRAM][AUTH] Creating new user from Telegram chat', { chatId });
      const newUser = await authService.signup(signupPayload);
      console.log('üéâ [TELEGRAM][AUTH] Signup successful', {
        chatId,
        userId: newUser._id,
      });
      const token = authService.generateToken(newUser);
      return { user: newUser, token, isNew: true };
    } catch (error: any) {
      if (error.message?.toLowerCase().includes('already exists')) {
        console.warn('‚ôªÔ∏è [TELEGRAM][AUTH] Signup reported existing user, retrying login', {
          chatId,
          error: error.message,
        });
        const fallbackUser = await authService.login({ telegramChatId: chatId });
        if (fallbackUser) {
          await this.syncTelegramProfile(fallbackUser, signupPayload);
          console.log('‚úÖ [TELEGRAM][AUTH] Fallback login succeeded after signup conflict', {
            chatId,
            userId: fallbackUser._id,
          });
          const token = authService.generateToken(fallbackUser);
          return { user: fallbackUser, token, isNew: false };
        }
      }
      console.error('‚ùå [TELEGRAM][AUTH] Failed to ensure user/token', {
        chatId,
        error: error.message || error,
      });
      throw error;
    }
  }

  private async updateChatMenuButton(chatId: number, url: string): Promise<void> {
    if (!this.bot) return;

    try {
      await this.bot.setChatMenuButton({
        chat_id: chatId,
        menu_button: {
          type: 'web_app',
          text: this.defaultWebAppText,
          web_app: { url },
        } as any,
      });
      console.log('üÜô [TELEGRAM] Chat menu button updated', { chatId, url });
    } catch (error: any) {
      console.warn(
        '‚ö†Ô∏è [TELEGRAM] Failed to update chat menu button:',
        error.message || error,
      );
    }
  }

  private async ensureDefaultMenuButton(url: string): Promise<void> {
    if (!this.bot) return;

    try {
      await this.bot.setChatMenuButton({
        menu_button: {
          type: 'web_app',
          text: this.defaultWebAppText,
          web_app: { url },
        } as any,
      });
      console.log('üÜô [TELEGRAM] Default menu button set', { url });
    } catch (error: any) {
      console.warn(
        '‚ö†Ô∏è [TELEGRAM] Failed to set default menu button:',
        error.message || error,
      );
    }
  }

  /**
   * Validates if the Telegram bot token is valid (not a placeholder)
   */
  private isValidToken(token: string): boolean {
    if (!token || token.trim() === '') {
      return false;
    }
    
    // Check if it's the placeholder value
    const placeholderValues = [
      'your-telegram-bot-token-here',
      'your-secret-key',
      'placeholder',
      'example'
    ];
    
    if (placeholderValues.some(placeholder => 
      token.toLowerCase().includes(placeholder.toLowerCase())
    )) {
      return false;
    }
    
    // Telegram bot tokens have format: numbers:letters (e.g., "123456789:ABCdefGHIjklMNOpqrsTUVwxyz")
    // They should contain a colon and be at least 35 characters
    const tokenPattern = /^\d+:[A-Za-z0-9_-]{35,}$/;
    return tokenPattern.test(token);
  }

  initialize(): TelegramBot {
    if (!env.TELEGRAM_BOT_TOKEN) {
      throw new Error('TELEGRAM_BOT_TOKEN is not set in environment variables');
    }

    // Validate token is not a placeholder
    if (!this.isValidToken(env.TELEGRAM_BOT_TOKEN)) {
      throw new Error(
        'TELEGRAM_BOT_TOKEN appears to be a placeholder. ' +
        'Please set a valid Telegram bot token from @BotFather'
      );
    }

    if (!this.bot) {
      try {
        // Check if webhook URL is set, use webhook mode, otherwise use polling
        const useWebhook = env.TELEGRAM_WEBHOOK_URL && env.TELEGRAM_WEBHOOK_URL.trim() !== '';
        
        if (useWebhook && env.TELEGRAM_POLLING === false) {
          // Webhook mode - bot will receive updates via webhook endpoint
          this.bot = new TelegramBot(env.TELEGRAM_BOT_TOKEN, { webHook: false });
          this.isPolling = false;
          console.log('‚úÖ Telegram Bot initialized (Webhook mode)');
          console.log(`   Webhook URL: ${env.TELEGRAM_WEBHOOK_URL}`);
        } else {
          // Polling mode - bot will poll for updates
          this.bot = new TelegramBot(env.TELEGRAM_BOT_TOKEN, { polling: true });
          this.isPolling = true;
          console.log('‚úÖ Telegram Bot initialized (Polling mode)');
        }
        
        this.setupBotHandlers();
      const defaultMenuUrl = this.ensureHttps(this.getAppBaseUrl());
      this.ensureDefaultMenuButton(defaultMenuUrl).catch((error: any) =>
        console.warn('‚ö†Ô∏è [TELEGRAM] Could not configure default menu button:', error.message || error),
      );
      } catch (error: any) {
        this.bot = null;
        this.isPolling = false;
        throw new Error(`Failed to initialize Telegram Bot: ${error.message}`);
      }
    }

    return this.bot;
  }

  /**
   * Set webhook URL in Telegram
   */
  async setWebhook(webhookUrl: string): Promise<void> {
    if (!this.bot) {
      throw new Error('Bot is not initialized');
    }
    
    await this.bot.setWebHook(webhookUrl);
    console.log(`‚úÖ Webhook URL set: ${webhookUrl}`);
  }

  /**
   * Get webhook info from Telegram
   */
  async getWebhookInfo(): Promise<any> {
    if (!this.bot) {
      throw new Error('Bot is not initialized');
    }
    
    return await this.bot.getWebHookInfo();
  }

  /**
   * Delete webhook from Telegram
   */
  async deleteWebhook(): Promise<void> {
    if (!this.bot) {
      throw new Error('Bot is not initialized');
    }
    
    await this.bot.deleteWebHook();
    console.log('‚úÖ Webhook deleted');
  }

  /**
   * Stops the bot polling gracefully
   */
  stopPolling(): void {
    if (this.bot && this.isPolling) {
      try {
        this.bot.stopPolling();
        this.isPolling = false;
        console.log('üõë Telegram Bot polling stopped');
      } catch (error: any) {
        console.error('Error stopping Telegram Bot polling:', error.message);
      }
    }
  }

  private setupBotHandlers(): void {
    if (!this.bot) return;

    // Start command
    this.bot.onText(/\/start/, async (msg: Message) => {
      const chatId = this.getChatId(msg);
      const firstName = msg.from?.first_name || 'there';
      console.log('‚ö° [TELEGRAM] /start command received', {
        chatId,
        firstName,
        username: msg.from?.username,
      });

      try {
        const { isNew, token } = await this.ensureUserAndToken(msg);
        console.log('‚úÖ [TELEGRAM] User ensured via /start', {
          chatId,
          isNew,
        });
        const loginUrl = this.buildLoginUrl(chatId, token);
        console.log('üåê [TELEGRAM] Login URL generated via /start', {
          chatId,
          loginUrl,
        });
        await this.updateChatMenuButton(chatId, loginUrl);

        const intro = isNew
          ? `Hi ${firstName}! üéâ Your AI Earn Bot account has been created automatically.`
          : `Welcome back ${firstName}! üîê You're already registered, so we logged you in.`;

        const message = [
          intro,
          '',
          `Chat ID: ${chatId}`,
          'Tap "Launch Web App" below or type "launch" anytime to open the dashboard without entering credentials.',
          '',
          'Commands:',
          '/start - Auto-register or login again',
          '/myid - Show your Chat ID',
          '/help - How everything works',
          '/link - Get a fresh launch link',
        ].join('\n');

        await this.bot!.sendMessage(chatId, message, {
          reply_markup: this.buildLaunchKeyboard(loginUrl),
        });
        console.log('üí¨ [TELEGRAM] Sent /start welcome message', { chatId });
        await this.sendLaunchReplyKeyboard(chatId);
      } catch (error: any) {
        console.error('‚ùå [TELEGRAM] Failed to process /start:', error);
        await this.bot!.sendMessage(
          chatId,
          '‚ùå Unable to register/login automatically right now. Please try again in a moment.',
        );
      }
    });

    // Launch/Open commands
    this.bot.onText(/^(open|launch)$/i, async (msg: Message) => {
      const chatId = this.getChatId(msg);
      console.log('‚ö° [TELEGRAM] launch/open command received', {
        chatId,
        command: msg.text,
      });

      try {
        const { token } = await this.ensureUserAndToken(msg);
        console.log('‚úÖ [TELEGRAM] User ensured via launch command', { chatId });
        const loginUrl = this.buildLoginUrl(chatId, token);
        console.log('üåê [TELEGRAM] Login URL generated via launch command', {
          chatId,
          loginUrl,
        });
        await this.updateChatMenuButton(chatId, loginUrl);

        await this.bot!.sendMessage(
          chatId,
          'üöÄ Launching AI Earn Bot inside Telegram. Tap the button below if it does not open automatically.',
          {
            reply_markup: this.buildLaunchKeyboard(loginUrl),
          },
        );
        console.log('üí¨ [TELEGRAM] Sent launch instruction message', { chatId });
        await this.sendLaunchReplyKeyboard(chatId);
      } catch (error: any) {
        console.error('‚ùå [TELEGRAM] Failed to process launch command:', error);
        await this.bot!.sendMessage(
          chatId,
          '‚ùå Could not log you in automatically. Please use /start to try again.',
        );
      }
    });

    // Get Chat ID command
    this.bot.onText(/\/myid/, async (msg: Message) => {
      const chatId = this.getChatId(msg);
      
      await this.bot!.sendMessage(
        chatId,
        `Your Telegram Chat ID: \`${chatId}\`\n\n` +
        `Use this ID to authenticate in the application.`,
        { parse_mode: 'Markdown' }
      );
    });

    // Help command
    this.bot.onText(/\/help/, async (msg: Message) => {
      const chatId = this.getChatId(msg);
      const appUrl = this.getAppBaseUrl();
      
      await this.bot!.sendMessage(
        chatId,
        `ü§ñ *AI Earn Bot Help*\n\n` +
        `*Commands:*\n` +
        `/start - Start the bot and get your Chat ID\n` +
        `/myid - Get your Telegram Chat ID\n` +
        `/help - Show this help message\n` +
        `/link - Get instant login link\n` +
        `launch / open - Directly launch the web app\n\n` +
        `*Authentication:*\n` +
        `1. Use /start once and we auto-register you\n` +
        `2. Use "launch" to auto-login anytime\n` +
        `3. Your Chat ID (${chatId}) stays linked with your account\n\n` +
        `*Visit App:*\n` +
        `[Click here to open the app](${appUrl})`,
        { 
          parse_mode: 'Markdown',
          disable_web_page_preview: false
        }
      );
    });

    // Link command - Example of masked URL
    this.bot.onText(/\/link/, async (msg: Message) => {
      const chatId = this.getChatId(msg);
      console.log('‚ö° [TELEGRAM] /link command received', { chatId });

      try {
        const { token } = await this.ensureUserAndToken(msg);
        console.log('‚úÖ [TELEGRAM] User ensured via /link', { chatId });
        const loginUrl = this.buildLoginUrl(chatId, token);
        console.log('üåê [TELEGRAM] Login URL generated via /link', {
          chatId,
          loginUrl,
        });

        await this.sendMessageWithLink(
          chatId,
          'üöÄ Open AI Earn Bot App',
          loginUrl,
          'Click the link below to access the application instantly:',
        );
        console.log('üí¨ [TELEGRAM] Sent /link response with login URL', { chatId });
      } catch (error: any) {
        console.error('‚ùå [TELEGRAM] Failed to generate link:', error);
        await this.bot!.sendMessage(
          chatId,
          '‚ùå Could not create a login link right now. Please try /start again shortly.',
        );
      }
    });

    // Handle errors
    this.bot.on('polling_error', (error: any) => {
      // Check if it's a 404 error (invalid token)
      const is404Error = 
        error.code === 'ETELEGRAM' && (
          error.response?.statusCode === 404 ||
          error.response?.body?.error_code === 404 ||
          error.message?.includes('404') ||
          error.message?.includes('Not Found')
        );

      if (is404Error) {
        console.error('‚ùå Telegram Bot token is invalid (404 Not Found)');
        console.error('   Please check your TELEGRAM_BOT_TOKEN in .env file');
        console.error('   Get a valid token from @BotFather on Telegram');
        console.error('   Stopping Telegram Bot polling to prevent continuous errors...');
        // Stop polling to prevent continuous errors
        this.stopPolling();
        this.bot = null;
      } else {
        console.error('Telegram Bot polling error:', error.message || error);
      }
    });
  }

  getBot(): TelegramBot | null {
    return this.bot;
  }

  async sendMessage(chatId: number, message: string, options?: any): Promise<void> {
    if (!this.bot) {
      throw new Error('Telegram bot is not initialized');
    }
    await this.bot.sendMessage(chatId, message, options);
  }

  /**
   * Send message with masked URL (Markdown format)
   * @param chatId - Telegram chat ID
   * @param text - Link text to display
   * @param url - URL to link to
   * @param additionalText - Optional additional text before/after link
   */
  async sendMessageWithLink(
    chatId: number,
    text: string,
    url: string,
    additionalText?: string
  ): Promise<void> {
    if (!this.bot) {
      throw new Error('Telegram bot is not initialized');
    }

    const linkText = `[${text}](${url})`;
    const message = additionalText 
      ? `${additionalText}\n\n${linkText}` 
      : linkText;

    await this.bot.sendMessage(chatId, message, {
      parse_mode: 'Markdown',
      disable_web_page_preview: false, // Set to true if you don't want URL preview
    });
  }

  /**
   * Send message with masked URL (HTML format)
   * @param chatId - Telegram chat ID
   * @param text - Link text to display
   * @param url - URL to link to
   * @param additionalText - Optional additional text before/after link
   */
  async sendMessageWithLinkHTML(
    chatId: number,
    text: string,
    url: string,
    additionalText?: string
  ): Promise<void> {
    if (!this.bot) {
      throw new Error('Telegram bot is not initialized');
    }

    const linkText = `<a href="${url}">${text}</a>`;
    const message = additionalText 
      ? `${additionalText}\n\n${linkText}` 
      : linkText;

    await this.bot.sendMessage(chatId, message, {
      parse_mode: 'HTML',
      disable_web_page_preview: false,
    });
  }

  /**
   * Send message with multiple masked links
   * @param chatId - Telegram chat ID
   * @param links - Array of {text, url} objects
   * @param message - Optional message text
   */
  async sendMessageWithMultipleLinks(
    chatId: number,
    links: Array<{ text: string; url: string }>,
    message?: string
  ): Promise<void> {
    if (!this.bot) {
      throw new Error('Telegram bot is not initialized');
    }

    const linkTexts = links.map(link => `[${link.text}](${link.url})`).join('\n');
    const fullMessage = message 
      ? `${message}\n\n${linkTexts}` 
      : linkTexts;

    await this.bot.sendMessage(chatId, fullMessage, {
      parse_mode: 'Markdown',
      disable_web_page_preview: false,
    });
  }

  async verifyChatId(chatId: number): Promise<boolean> {
    if (!this.bot) {
      return false;
    }

    try {
      const chat = await this.bot.getChat(chatId);
      return !!chat;
    } catch (error) {
      return false;
    }
  }
}

export const telegramService = new TelegramService();

