import TelegramBot from 'node-telegram-bot-api';
import type { Message, InlineKeyboardMarkup, ReplyKeyboardMarkup } from 'node-telegram-bot-api';
import { env } from '../config/env';
import { authService } from '../features/auth/services/auth.service';
import type { SignupDto } from '../features/auth/types/auth.types';
import type { IUser } from '../features/users/models/user.model';
import { User } from '../features/users/models/user.model';

class TelegramService {
  private bot: TelegramBot | null = null;
  private isPolling: boolean = false;
  private readonly defaultWebAppText = 'OPEN';

  private getAppBaseUrl(): string {
    return env.APP_URL?.trim() ;
  }

  private getChatId(msg: Message): number {
    console.log('ğŸ” [TELEGRAM] Getting chat ID:', msg.chat.id);
    console.log('ğŸ” [TELEGRAM] Message:', msg);
    const chatId = msg.chat.id;
    return typeof chatId === 'number' ? chatId : Number(chatId);
  }

  private async syncTelegramProfile(
    user: IUser,
    profile: SignupDto,
  ): Promise<IUser> {
    const updates: Partial<IUser> = {};

    if (profile.telegramFirstName && profile.telegramFirstName !== user.telegramFirstName) {
      updates.telegramFirstName = profile.telegramFirstName;
    }

    if (profile.telegramLastName && profile.telegramLastName !== user.telegramLastName) {
      updates.telegramLastName = profile.telegramLastName;
    }

    if (profile.telegramUsername && profile.telegramUsername !== user.telegramUsername) {
      updates.telegramUsername = profile.telegramUsername;
    }

    const isAutoGeneratedName =
      user.name?.startsWith('AiCrypto User') ||
      user.name?.startsWith('AiCrypto Bot User');

    if (
      profile.name &&
      profile.name.trim().length > 0 &&
      (isAutoGeneratedName || !user.name || user.name.trim().length === 0)
    ) {
      updates.name = profile.name.trim();
    }

    if (Object.keys(updates).length > 0) {
      console.log('ğŸ“ [TELEGRAM] Syncing Telegram profile fields to user document', {
        userId: user._id,
        chatId: user.telegramChatId,
        updates,
      });
      await User.updateOne({ _id: user._id }, { $set: updates });
      Object.assign(user, updates);
    }

    return user;
  }

  private buildLaunchKeyboard(url: string): InlineKeyboardMarkup {
    return {
      inline_keyboard: [
        [
          {
            text: 'Launch Web App',
            web_app: { url },
          },
        ],
      ],
    };
  }

  private buildLaunchReplyKeyboard(): ReplyKeyboardMarkup {
    return {
      keyboard: [
        [
          {
            text: 'launch',
          },
        ],
      ],
      resize_keyboard: true,
      one_time_keyboard: false,
      input_field_placeholder: 'Tap launch or type a command',
    };
  }

  private ensureHttps(originalUrl: string): string {
    if (!originalUrl) {
      return originalUrl;
    }

    try {
      const parsed = new URL(
        originalUrl.startsWith('http') ? originalUrl : `https://${originalUrl}`,
      );

      if (parsed.protocol !== 'https:') {
        parsed.protocol = 'https:';
        const httpsUrl = parsed.toString();
        console.warn('âš ï¸ [TELEGRAM] Upgrading URL to HTTPS for Telegram requirements', {
          originalUrl,
          httpsUrl,
        });
        return httpsUrl;
      }

      return parsed.toString();
    } catch {
      if (originalUrl.startsWith('http://')) {
        const httpsUrl = `https://${originalUrl.slice('http://'.length)}`;
        console.warn('âš ï¸ [TELEGRAM] Converted http URL to https', { originalUrl, httpsUrl });
        return httpsUrl;
      }

      if (!originalUrl.startsWith('https://')) {
        const httpsUrl = `https://${originalUrl}`;
        console.warn('âš ï¸ [TELEGRAM] Prefixed URL with https://', { originalUrl, httpsUrl });
        return httpsUrl;
      }

      return originalUrl;
    }
  }

  private async sendLaunchReplyKeyboard(chatId: number): Promise<void> {
    if (!this.bot) return;
    try {
      await this.bot.sendMessage(
        chatId,
        'âŒ¨ï¸ Launch button added at the bottom keyboard.',
        {
          reply_markup: this.buildLaunchReplyKeyboard(),
        },
      );
    } catch (error: any) {
      console.warn('âš ï¸ [TELEGRAM] Failed to send launch reply keyboard:', error.message || error);
    }
  }

  private buildLoginUrl(chatId: number, token: string): string {
    const baseUrl = this.getAppBaseUrl();
    console.log(`ğŸ”— [TELEGRAM] Preparing login URL`, {
      chatId,
      baseUrl,
    });
    const params = new URLSearchParams({
      chatId: String(chatId),
      token,
      source: 'telegram',
    });

    try {
      const url = new URL(baseUrl);
      params.forEach((value, key) => url.searchParams.set(key, value));
      url.searchParams.set('ts', Date.now().toString());
      return this.ensureHttps(url.toString());
    } catch {
      const separator = baseUrl.includes('?') ? '&' : '?';
      params.set('ts', Date.now().toString());
      return this.ensureHttps(`${baseUrl}${separator}${params.toString()}`);
    }
  }

  private extractSignupPayload(msg: Message, referralCode?: string): SignupDto {
    console.log('ğŸ“‹ [TELEGRAM][PAYLOAD] Extracting signup payload from message');
    
    const chatId = this.getChatId(msg);
    const from = msg.from;
    const firstName = from?.first_name?.trim();
    const lastName = from?.last_name?.trim();
    const username = from?.username?.trim();

    console.log('ğŸ“‹ [TELEGRAM][PAYLOAD] User details extracted', {
      chatId,
      firstName: firstName || 'N/A',
      lastName: lastName || 'N/A',
      username: username || 'N/A',
      referralCode: referralCode || 'none',
    });

    const fallbackNameParts = [firstName, lastName].filter(Boolean);
    const fallbackName =
      fallbackNameParts.join(' ').trim() || username || `AiCrypto User ${chatId}`;

    const payload = {
      telegramChatId: chatId,
      telegramUsername: username,
      telegramFirstName: firstName,
      telegramLastName: lastName,
      name: fallbackName,
      referralCode: referralCode && referralCode.trim() ? referralCode.trim() : undefined,
    };

    console.log('âœ… [TELEGRAM][PAYLOAD] Signup payload created', {
      chatId,
      name: fallbackName,
      hasReferralCode: !!referralCode,
      referralCode: referralCode || 'none',
    });

    return payload;
  }

  private async ensureUserAndToken(msg: Message, referralCode?: string): Promise<{
    user: IUser;
    token: string;
    isNew: boolean;
  }> {
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    console.log('ğŸ” [TELEGRAM][AUTH] Starting ensureUserAndToken process');
    console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
    
    console.log('ğŸ“ [TELEGRAM][AUTH] Step A: Extracting signup payload');
    const signupPayload = this.extractSignupPayload(msg, referralCode);
    const chatId = signupPayload.telegramChatId;
    
    console.log('âœ… [TELEGRAM][AUTH] Step A Complete: Payload extracted', {
      chatId,
      username: signupPayload.telegramUsername || 'N/A',
      firstName: signupPayload.telegramFirstName || 'N/A',
      name: signupPayload.name,
      referralCode: referralCode || 'none',
    });

    // Try to login existing user first
    console.log('ğŸ” [TELEGRAM][AUTH] Step B: Checking for existing user');
    try {
      console.log('ğŸ” [TELEGRAM][AUTH] Step B.1: Calling authService.login', {
        chatId,
      });
      
      const existingUser = await authService.login({ telegramChatId: chatId });
      
      if (existingUser) {
        console.log('âœ… [TELEGRAM][AUTH] Step B.2: Existing user found', {
          chatId,
          userId: existingUser._id,
          userName: existingUser.name,
          userReferralCode: existingUser.referralCode,
        });
        
        console.log('ğŸ”„ [TELEGRAM][AUTH] Step B.3: Syncing Telegram profile');
        await this.syncTelegramProfile(existingUser, signupPayload);
        
        console.log('âœ… [TELEGRAM][AUTH] Step B.4: Profile synced, generating token');
        const token = authService.generateToken(existingUser);
        
        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        console.log('âœ… [TELEGRAM][AUTH] Existing user login successful', {
          chatId,
          userId: existingUser._id,
          isNew: false,
        });
        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        
        return { user: existingUser, token, isNew: false };
      }
      
      console.log('â„¹ï¸  [TELEGRAM][AUTH] Step B: No existing user found');
    } catch (error: any) {
      if (error.message?.toLowerCase().includes('inactive')) {
        console.error('âŒ [TELEGRAM][AUTH] User account is inactive', {
          chatId,
          error: error.message,
        });
        throw error;
      }
      console.warn('âš ï¸ [TELEGRAM][AUTH] Step B: Login attempt failed, will try signup', {
        chatId,
        error: error.message || error,
      });
    }

    // Create new user
    console.log('ğŸ†• [TELEGRAM][AUTH] Step C: Creating new user');
    try {
      console.log('ğŸ†• [TELEGRAM][AUTH] Step C.1: Calling authService.signup', { 
        chatId,
        name: signupPayload.name,
        referralCode: referralCode || 'none',
        hasReferralCode: !!referralCode,
        signupPayloadReferralCode: signupPayload.referralCode || 'none',
        fullSignupPayload: JSON.stringify(signupPayload),
      });
      
      const newUser = await authService.signup(signupPayload);
      
      console.log('ğŸ‰ [TELEGRAM][AUTH] Step C.2: New user created successfully', {
        chatId,
        userId: newUser._id,
        userName: newUser.name,
        userReferralCode: newUser.referralCode,
        referredBy: newUser.referredBy || 'none',
        providedReferralCode: referralCode || 'none',
      });
      
      console.log('ğŸ”‘ [TELEGRAM][AUTH] Step C.3: Generating authentication token');
      const token = authService.generateToken(newUser);
      
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      console.log('âœ… [TELEGRAM][AUTH] New user signup successful', {
        chatId,
        userId: newUser._id,
        isNew: true,
        referralCode: referralCode || 'none',
      });
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      
      return { user: newUser, token, isNew: true };
    } catch (error: any) {
      if (error.message?.toLowerCase().includes('already exists')) {
        console.warn('â™»ï¸ [TELEGRAM][AUTH] Step C: Signup reported existing user (race condition)', {
          chatId,
          error: error.message,
        });
        
        console.log('ğŸ”„ [TELEGRAM][AUTH] Step D: Retrying login after signup conflict');
        const fallbackUser = await authService.login({ telegramChatId: chatId });
        
        if (fallbackUser) {
          console.log('âœ… [TELEGRAM][AUTH] Step D.1: Fallback user found');
          await this.syncTelegramProfile(fallbackUser, signupPayload);
          
          console.log('âœ… [TELEGRAM][AUTH] Step D.2: Generating token for fallback user');
          const token = authService.generateToken(fallbackUser);
          
          console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
          console.log('âœ… [TELEGRAM][AUTH] Fallback login successful', {
            chatId,
            userId: fallbackUser._id,
            isNew: false,
          });
          console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
          
          return { user: fallbackUser, token, isNew: false };
        }
      }
      
      console.error('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      console.error('âŒ [TELEGRAM][AUTH] Failed to ensure user/token', {
        chatId,
        error: error.message || error,
        stack: error.stack,
      });
      console.error('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      
      throw error;
    }
  }

  private async updateChatMenuButton(chatId: number, url: string): Promise<void> {
    if (!this.bot) return;

    try {
      await this.bot.setChatMenuButton({
        chat_id: chatId,
        menu_button: {
          type: 'web_app',
          text: this.defaultWebAppText,
          web_app: { url },
        } as any,
      });
      console.log('ğŸ†™ [TELEGRAM] Chat menu button updated', { chatId, url });
    } catch (error: any) {
      console.warn(
        'âš ï¸ [TELEGRAM] Failed to update chat menu button:',
        error.message || error,
      );
    }
  }

  private async ensureDefaultMenuButton(url: string): Promise<void> {
    if (!this.bot) return;

    try {
      await this.bot.setChatMenuButton({
        menu_button: {
          type: 'web_app',
          text: this.defaultWebAppText,
          web_app: { url },
        } as any,
      });
      console.log('ğŸ†™ [TELEGRAM] Default menu button set', { url });
    } catch (error: any) {
      console.warn(
        'âš ï¸ [TELEGRAM] Failed to set default menu button:',
        error.message || error,
      );
    }
  }

  /**
   * Validates if the Telegram bot token is valid (not a placeholder)
   */
  private isValidToken(token: string): boolean {
    if (!token || token.trim() === '') {
      return false;
    }
    
    // Check if it's the placeholder value
    const placeholderValues = [
      'your-telegram-bot-token-here',
      'your-secret-key',
      'placeholder',
      'example'
    ];
    
    if (placeholderValues.some(placeholder => 
      token.toLowerCase().includes(placeholder.toLowerCase())
    )) {
      return false;
    }
    
    // Telegram bot tokens have format: numbers:letters (e.g., "123456789:ABCdefGHIjklMNOpqrsTUVwxyz")
    // They should contain a colon and be at least 35 characters
    const tokenPattern = /^\d+:[A-Za-z0-9_-]{35,}$/;
    return tokenPattern.test(token);
  }

  initialize(): TelegramBot {
    if (!env.TELEGRAM_BOT_TOKEN) {
      throw new Error('TELEGRAM_BOT_TOKEN is not set in environment variables');
    }

    // Validate token is not a placeholder
    if (!this.isValidToken(env.TELEGRAM_BOT_TOKEN)) {
      throw new Error(
        'TELEGRAM_BOT_TOKEN appears to be a placeholder. ' +
        'Please set a valid Telegram bot token from @BotFather'
      );
    }

    if (!this.bot) {
      try {
        // Check if webhook URL is set, use webhook mode, otherwise use polling
        const useWebhook = env.TELEGRAM_WEBHOOK_URL && env.TELEGRAM_WEBHOOK_URL.trim() !== '';
        
        if (useWebhook && env.TELEGRAM_POLLING === false) {
          // Webhook mode - bot will receive updates via webhook endpoint
          this.bot = new TelegramBot(env.TELEGRAM_BOT_TOKEN, { webHook: false });
          this.isPolling = false;
          console.log('âœ… Telegram Bot initialized (Webhook mode)');
          console.log(`   Webhook URL: ${env.TELEGRAM_WEBHOOK_URL}`);
        } else {
          // Polling mode - bot will poll for updates
          this.bot = new TelegramBot(env.TELEGRAM_BOT_TOKEN, { polling: true });
          this.isPolling = true;
          console.log('âœ… Telegram Bot initialized (Polling mode)');
        }
        
        this.setupBotHandlers();
      const defaultMenuUrl = this.ensureHttps(this.getAppBaseUrl());
      this.ensureDefaultMenuButton(defaultMenuUrl).catch((error: any) =>
        console.warn('âš ï¸ [TELEGRAM] Could not configure default menu button:', error.message || error),
      );
      } catch (error: any) {
        this.bot = null;
        this.isPolling = false;
        throw new Error(`Failed to initialize Telegram Bot: ${error.message}`);
      }
    }

    return this.bot;
  }

  /**
   * Set webhook URL in Telegram
   */
  async setWebhook(webhookUrl: string): Promise<void> {
    if (!this.bot) {
      throw new Error('Bot is not initialized');
    }
    
    await this.bot.setWebHook(webhookUrl);
    console.log(`âœ… Webhook URL set: ${webhookUrl}`);
  }

  /**
   * Get webhook info from Telegram
   */
  async getWebhookInfo(): Promise<any> {
    if (!this.bot) {
      throw new Error('Bot is not initialized');
    }
    
    return await this.bot.getWebHookInfo();
  }

  /**
   * Delete webhook from Telegram
   */
  async deleteWebhook(): Promise<void> {
    if (!this.bot) {
      throw new Error('Bot is not initialized');
    }
    
    await this.bot.deleteWebHook();
    console.log('âœ… Webhook deleted');
  }

  /**
   * Stops the bot polling gracefully
   */
  stopPolling(): void {
    if (this.bot && this.isPolling) {
      try {
        this.bot.stopPolling();
        this.isPolling = false;
        console.log('ğŸ›‘ Telegram Bot polling stopped');
      } catch (error: any) {
        console.error('Error stopping Telegram Bot polling:', error.message);
      }
    }
  }

  private setupBotHandlers(): void {
    if (!this.bot) return;

    // Start command
    this.bot.onText(/\/start/, async (msg: Message) => {
      const chatId = this.getChatId(msg);
      const firstName = msg.from?.first_name || 'there';
      
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      console.log('ğŸš€ [TELEGRAM][START] Processing /start command');
      console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      
      // Extract referral code from /start command (e.g., /start AI75F8B884 or /start=AI75F8B884)
      const messageText = msg.text || '';
      console.log('ğŸ“ [TELEGRAM][START] Step 1: Extracting referral code from message', {
        messageText,
        chatId,
        fullMessage: JSON.stringify(msg),
      });
      
      let referralCode: string | undefined = undefined;
      
      // Remove the /start command part to get the parameter
      // Handle formats: /start CODE, /start=CODE, /start?code=CODE
      const startCommandMatch = messageText.match(/^\/start\s*/i);
      if (startCommandMatch) {
        // Get everything after /start
        const afterStart = messageText.substring(startCommandMatch[0].length).trim();
        
        console.log('ğŸ” [TELEGRAM][START] Content after /start command:', {
          afterStart,
          length: afterStart.length,
          chatId,
        });
        
        if (afterStart) {
          // Handle equals format: /start=CODE
          if (afterStart.startsWith('=')) {
            const extracted = afterStart.substring(1).trim();
            // Take first word/token (everything until space or end)
            referralCode = extracted.split(/\s+/)[0].trim();
          }
          // Handle URL query format: /start?code=CODE or /start?ref=CODE
          else if (afterStart.includes('?') || afterStart.includes('=')) {
            try {
              const urlParams = new URLSearchParams(afterStart.includes('?') ? afterStart.split('?')[1] : `code=${afterStart}`);
              referralCode = urlParams.get('code') || urlParams.get('ref') || (afterStart.includes('=') ? afterStart.split('=')[1] : afterStart);
            } catch {
              // If URL parsing fails, try simple extraction
              const equalIndex = afterStart.indexOf('=');
              if (equalIndex >= 0) {
                referralCode = afterStart.substring(equalIndex + 1).trim().split(/\s+/)[0];
              } else {
                referralCode = afterStart.trim().split(/\s+/)[0];
              }
            }
          }
          // Handle space-separated format: /start CODE
          else {
            referralCode = afterStart.trim().split(/\s+/)[0];
          }
          
          // Clean and validate referral code
          if (referralCode) {
            referralCode = referralCode.trim().toUpperCase();
            // Remove any invalid characters (keep only alphanumeric)
            referralCode = referralCode.replace(/[^A-Z0-9]/g, '');
            
            // Validate minimum length (at least 4 characters)
            if (referralCode.length < 4) {
              console.log('âš ï¸ [TELEGRAM][START] Referral code too short, ignoring', {
                referralCode,
                length: referralCode.length,
                chatId,
              });
              referralCode = undefined;
            }
          }
        }
      }
      
      if (referralCode) {
        console.log('âœ… [TELEGRAM][START] Step 1 Complete: Referral code extracted', {
          referralCode,
          codeLength: referralCode.length,
          chatId,
          rawMessageText: messageText,
        });
      } else {
        console.log('â„¹ï¸  [TELEGRAM][START] Step 1 Complete: No referral code provided', {
          chatId,
          rawMessageText: messageText,
          hasEquals: messageText.includes('='),
          hasSpace: messageText.includes(' '),
          messageLength: messageText.length,
        });
      }
      
      console.log('âš¡ [TELEGRAM][START] Step 2: User information', {
        chatId,
        firstName,
        lastName: msg.from?.last_name,
        username: msg.from?.username,
        referralCode: referralCode || 'none',
      });

      try {
        console.log('ğŸ”„ [TELEGRAM][START] Step 3: Calling ensureUserAndToken', {
          chatId,
          referralCode: referralCode || 'none',
        });
        
        const { isNew, token } = await this.ensureUserAndToken(msg, referralCode);
        
        console.log('âœ… [TELEGRAM][START] Step 3 Complete: User ensured successfully', {
          chatId,
          isNew,
          userStatus: isNew ? 'NEW_USER_CREATED' : 'EXISTING_USER_LOGIN',
          referralCode: referralCode || 'none',
        });
        
        console.log('ğŸ”— [TELEGRAM][START] Step 4: Building login URL', {
          chatId,
        });
        
        const loginUrl = this.buildLoginUrl(chatId, token);
        
        console.log('âœ… [TELEGRAM][START] Step 4 Complete: Login URL generated', {
          chatId,
          urlLength: loginUrl.length,
          urlPreview: loginUrl.substring(0, 50) + '...',
        });
        
        console.log('ğŸ¨ [TELEGRAM][START] Step 5: Updating chat menu button', {
          chatId,
        });
        
        await this.updateChatMenuButton(chatId, loginUrl);
        
        console.log('âœ… [TELEGRAM][START] Step 5 Complete: Menu button updated', {
          chatId,
        });

        console.log('ğŸ’¬ [TELEGRAM][START] Step 6: Preparing welcome message', {
          chatId,
          isNew,
          hasReferralCode: !!referralCode,
        });

        const intro = isNew
          ? referralCode
            ? `Hi ${firstName}! ğŸ‰ Your AiCrypto Bot account has been created with referral code: ${referralCode}`
            : `Hi ${firstName}! ğŸ‰ Your AiCrypto Bot account has been created automatically.`
          : `Welcome back ${firstName}! ğŸ” You're already registered, so we logged you in.`;

        const message = [
          intro,
          '',
          `Chat ID: ${chatId}`,
          'Tap "Launch Web App" below or type "launch" anytime to open the dashboard without entering credentials.',
          '',
          'Commands:',
          '/start - Auto-register or login again',
          '/myid - Show your Chat ID',
          '/help - How everything works',
          '/qa - Questions & Answers',
          '/news - Official News',
          '/support - Get Support',
          '/introduction - Introduction Guide',
          '/language - Change Language',
          '/referral - Referral Program',
        ].join('\n');

        console.log('ğŸ“¤ [TELEGRAM][START] Step 7: Sending welcome message to user', {
          chatId,
          messageLength: message.length,
        });

        await this.bot!.sendMessage(chatId, message, {
          reply_markup: this.buildLaunchKeyboard(loginUrl),
        });
        
        console.log('âœ… [TELEGRAM][START] Step 7 Complete: Welcome message sent', {
          chatId,
        });
        
        console.log('âŒ¨ï¸  [TELEGRAM][START] Step 8: Sending launch keyboard', {
          chatId,
        });
        
        await this.sendLaunchReplyKeyboard(chatId);
        
        console.log('âœ… [TELEGRAM][START] Step 8 Complete: Launch keyboard sent', {
          chatId,
        });
        
        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
        console.log('ğŸ‰ [TELEGRAM][START] /start command completed successfully', {
          chatId,
          isNew,
          referralCode: referralCode || 'none',
          totalSteps: 8,
        });
        console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
      } catch (error: any) {
        console.error('âŒ [TELEGRAM] Failed to process /start:', error);
        await this.bot!.sendMessage(
          chatId,
          'âŒ Unable to register/login automatically right now. Please try again in a moment.',
        );
      }
    });

    // Launch/Open commands
    this.bot.onText(/^(open|launch)$/i, async (msg: Message) => {
      const chatId = this.getChatId(msg);
      console.log('âš¡ [TELEGRAM] launch/open command received', {
        chatId,
        command: msg.text,
      });

      try {
        const { token } = await this.ensureUserAndToken(msg);
        console.log('âœ… [TELEGRAM] User ensured via launch command', { chatId });
        const loginUrl = this.buildLoginUrl(chatId, token);
        console.log('ğŸŒ [TELEGRAM] Login URL generated via launch command', {
          chatId,
          loginUrl,
        });
        await this.updateChatMenuButton(chatId, loginUrl);

        await this.bot!.sendMessage(
          chatId,
          'ğŸš€ Launching AiCrypto Bot inside Telegram. Tap the button below if it does not open automatically.',
          {
            reply_markup: this.buildLaunchKeyboard(loginUrl),
          },
        );
        console.log('ğŸ’¬ [TELEGRAM] Sent launch instruction message', { chatId });
        await this.sendLaunchReplyKeyboard(chatId);
      } catch (error: any) {
        console.error('âŒ [TELEGRAM] Failed to process launch command:', error);
        await this.bot!.sendMessage(
          chatId,
          'âŒ Could not log you in automatically. Please use /start to try again.',
        );
      }
    });

    // Get Chat ID command
    this.bot.onText(/\/myid/, async (msg: Message) => {
      const chatId = this.getChatId(msg);
      
      await this.bot!.sendMessage(
        chatId,
        `Your Telegram Chat ID: \`${chatId}\`\n\n` +
        `Use this ID to authenticate in the application.`,
        { parse_mode: 'Markdown' }
      );
    });

    // Help command
    this.bot.onText(/\/help/, async (msg: Message) => {
      const chatId = this.getChatId(msg);
      const appUrl = this.getAppBaseUrl();
      
      await this.bot!.sendMessage(
        chatId,
        `ğŸ¤– *AiCrypto Bot Help*\n\n` +
        `*Commands:*\n` +
        `/start - Start the bot and get your Chat ID\n` +
        `/myid - Get your Telegram Chat ID\n` +
        `/help - Show this help message\n` +
        `/qa - Questions & Answers\n` +
        `/news - Official News\n` +
        `/support - Get Support\n` +
        `/introduction - Introduction Guide\n` +
        `/language - Change Language\n` +
        `/referral - Referral Program\n` +
        `launch / open - Directly launch the web app\n\n` +
        `*Authentication:*\n` +
        `1. Use /start once and we auto-register you\n` +
        `2. Use "launch" to auto-login anytime\n` +
        `3. Your Chat ID (${chatId}) stays linked with your account\n\n` +
        `*Visit App:*\n` +
        `[Click here to open the app](${appUrl})`,
        { 
          parse_mode: 'Markdown',
          disable_web_page_preview: false
        }
      );
    });

    // Q&A command
    this.bot.onText(/\/qa/, async (msg: Message) => {
      const chatId = this.getChatId(msg);
      console.log('âš¡ [TELEGRAM] /qa command received', { chatId });

      try {
        const { token } = await this.ensureUserAndToken(msg);
        const qaUrl = this.buildLoginUrl(chatId, token).replace(/\?.*/, '') + '/qa?' + new URLSearchParams({
          chatId: String(chatId),
          token,
          source: 'telegram',
          ts: Date.now().toString(),
        }).toString();

        await this.sendMessageWithLink(
          chatId,
          'ğŸ“š Q&A - Questions & Answers',
          this.ensureHttps(qaUrl),
          'Get answers to frequently asked questions about AiCrypto Bot.'
        );
        console.log('ğŸ’¬ [TELEGRAM] Sent /qa response', { chatId });
      } catch (error: any) {
        console.error('âŒ [TELEGRAM] Failed to process /qa:', error);
        await this.bot!.sendMessage(
          chatId,
          'âŒ Could not access Q&A right now. Please try /start first.',
        );
      }
    });

    // Official News command
    this.bot.onText(/\/news/, async (msg: Message) => {
      const chatId = this.getChatId(msg);
      console.log('âš¡ [TELEGRAM] /news command received', { chatId });

      try {
        const { token } = await this.ensureUserAndToken(msg);
        const newsUrl = this.buildLoginUrl(chatId, token).replace(/\?.*/, '') + '/news?' + new URLSearchParams({
          chatId: String(chatId),
          token,
          source: 'telegram',
          ts: Date.now().toString(),
        }).toString();

        await this.sendMessageWithLink(
          chatId,
          'ğŸ“¢ Official News',
          this.ensureHttps(newsUrl),
          'Stay updated with the latest official news and announcements from AiCrypto Bot.'
        );
        console.log('ğŸ’¬ [TELEGRAM] Sent /news response', { chatId });
      } catch (error: any) {
        console.error('âŒ [TELEGRAM] Failed to process /news:', error);
        await this.bot!.sendMessage(
          chatId,
          'âŒ Could not access news right now. Please try /start first.',
        );
      }
    });

    // Support command
    this.bot.onText(/\/support/, async (msg: Message) => {
      const chatId = this.getChatId(msg);
      console.log('âš¡ [TELEGRAM] /support command received', { chatId });

      try {
        const { token } = await this.ensureUserAndToken(msg);
        const supportUrl = this.buildLoginUrl(chatId, token).replace(/\?.*/, '') + '/support?' + new URLSearchParams({
          chatId: String(chatId),
          token,
          source: 'telegram',
          ts: Date.now().toString(),
        }).toString();

        await this.sendMessageWithLink(
          chatId,
          'ğŸ‘¤ Support',
          this.ensureHttps(supportUrl),
          'Need help? Contact our support team for assistance with your account or any questions.'
        );
        console.log('ğŸ’¬ [TELEGRAM] Sent /support response', { chatId });
      } catch (error: any) {
        console.error('âŒ [TELEGRAM] Failed to process /support:', error);
        await this.bot!.sendMessage(
          chatId,
          'âŒ Could not access support right now. Please try /start first.',
        );
      }
    });

    // Introduction command
    this.bot.onText(/\/(intro|introduction)/, async (msg: Message) => {
      const chatId = this.getChatId(msg);
      console.log('âš¡ [TELEGRAM] /intro or /introduction command received', { chatId });

      try {
        const { token } = await this.ensureUserAndToken(msg);
        const introUrl = this.buildLoginUrl(chatId, token).replace(/\?.*/, '') + '/introduction?' + new URLSearchParams({
          chatId: String(chatId),
          token,
          source: 'telegram',
          ts: Date.now().toString(),
        }).toString();

        await this.sendMessageWithLink(
          chatId,
          'ğŸ“– Introduction',
          this.ensureHttps(introUrl),
          'Learn about AiCrypto Bot, how it works, and get started with your investment journey.'
        );
        console.log('ğŸ’¬ [TELEGRAM] Sent /introduction response', { chatId });
      } catch (error: any) {
        console.error('âŒ [TELEGRAM] Failed to process /introduction:', error);
        await this.bot!.sendMessage(
          chatId,
          'âŒ Could not access introduction right now. Please try /start first.',
        );
      }
    });

    // Language command
    this.bot.onText(/\/language/, async (msg: Message) => {
      const chatId = this.getChatId(msg);
      console.log('âš¡ [TELEGRAM] /language command received', { chatId });

      try {
        const { token } = await this.ensureUserAndToken(msg);
        const languageUrl = this.buildLoginUrl(chatId, token).replace(/\?.*/, '') + '/language?' + new URLSearchParams({
          chatId: String(chatId),
          token,
          source: 'telegram',
          ts: Date.now().toString(),
        }).toString();

        await this.sendMessageWithLink(
          chatId,
          'ğŸŒ Language Settings',
          this.ensureHttps(languageUrl),
          'Change your preferred language for the AiCrypto Bot interface.'
        );
        console.log('ğŸ’¬ [TELEGRAM] Sent /language response', { chatId });
      } catch (error: any) {
        console.error('âŒ [TELEGRAM] Failed to process /language:', error);
        await this.bot!.sendMessage(
          chatId,
          'âŒ Could not access language settings right now. Please try /start first.',
        );
      }
    });

    // Referral command
    this.bot.onText(/\/referral/, async (msg: Message) => {
      const chatId = this.getChatId(msg);
      console.log('âš¡ [TELEGRAM] /referral command received', { chatId });

      try {
        const { token } = await this.ensureUserAndToken(msg);
        const referralUrl = this.buildLoginUrl(chatId, token).replace(/\?.*/, '') + '/friends?' + new URLSearchParams({
          chatId: String(chatId),
          token,
          source: 'telegram',
          ts: Date.now().toString(),
        }).toString();

        await this.sendMessageWithLink(
          chatId,
          'ğŸ‘¥ Referral Program',
          this.ensureHttps(referralUrl),
          'Invite friends and earn rewards! Share your referral link and get bonuses when they join.'
        );
        console.log('ğŸ’¬ [TELEGRAM] Sent /referral response', { chatId });
      } catch (error: any) {
        console.error('âŒ [TELEGRAM] Failed to process /referral:', error);
        await this.bot!.sendMessage(
          chatId,
          'âŒ Could not access referral program right now. Please try /start first.',
        );
      }
    });

    // Handle errors
    this.bot.on('polling_error', (error: any) => {
      // Check if it's a 404 error (invalid token)
      const is404Error = 
        error.code === 'ETELEGRAM' && (
          error.response?.statusCode === 404 ||
          error.response?.body?.error_code === 404 ||
          error.message?.includes('404') ||
          error.message?.includes('Not Found')
        );

      if (is404Error) {
        console.error('âŒ Telegram Bot token is invalid (404 Not Found)');
        console.error('   Please check your TELEGRAM_BOT_TOKEN in .env file');
        console.error('   Get a valid token from @BotFather on Telegram');
        console.error('   Stopping Telegram Bot polling to prevent continuous errors...');
        // Stop polling to prevent continuous errors
        this.stopPolling();
        this.bot = null;
      } else {
        console.error('Telegram Bot polling error:', error.message || error);
      }
    });
  }

  getBot(): TelegramBot | null {
    return this.bot;
  }

  async sendMessage(chatId: number, message: string, options?: any): Promise<void> {
    if (!this.bot) {
      throw new Error('Telegram bot is not initialized');
    }
    await this.bot.sendMessage(chatId, message, options);
  }

  /**
   * Send message with masked URL (Markdown format)
   * @param chatId - Telegram chat ID
   * @param text - Link text to display
   * @param url - URL to link to
   * @param additionalText - Optional additional text before/after link
   */
  async sendMessageWithLink(
    chatId: number,
    text: string,
    url: string,
    additionalText?: string
  ): Promise<void> {
    if (!this.bot) {
      throw new Error('Telegram bot is not initialized');
    }

    const linkText = `[${text}](${url})`;
    const message = additionalText 
      ? `${additionalText}\n\n${linkText}` 
      : linkText;

    await this.bot.sendMessage(chatId, message, {
      parse_mode: 'Markdown',
      disable_web_page_preview: false, // Set to true if you don't want URL preview
    });
  }

  /**
   * Send message with masked URL (HTML format)
   * @param chatId - Telegram chat ID
   * @param text - Link text to display
   * @param url - URL to link to
   * @param additionalText - Optional additional text before/after link
   */
  async sendMessageWithLinkHTML(
    chatId: number,
    text: string,
    url: string,
    additionalText?: string
  ): Promise<void> {
    if (!this.bot) {
      throw new Error('Telegram bot is not initialized');
    }

    const linkText = `<a href="${url}">${text}</a>`;
    const message = additionalText 
      ? `${additionalText}\n\n${linkText}` 
      : linkText;

    await this.bot.sendMessage(chatId, message, {
      parse_mode: 'HTML',
      disable_web_page_preview: false,
    });
  }

  /**
   * Send message with multiple masked links
   * @param chatId - Telegram chat ID
   * @param links - Array of {text, url} objects
   * @param message - Optional message text
   */
  async sendMessageWithMultipleLinks(
    chatId: number,
    links: Array<{ text: string; url: string }>,
    message?: string
  ): Promise<void> {
    if (!this.bot) {
      throw new Error('Telegram bot is not initialized');
    }

    const linkTexts = links.map(link => `[${link.text}](${link.url})`).join('\n');
    const fullMessage = message 
      ? `${message}\n\n${linkTexts}` 
      : linkTexts;

    await this.bot.sendMessage(chatId, fullMessage, {
      parse_mode: 'Markdown',
      disable_web_page_preview: false,
    });
  }

  async verifyChatId(chatId: number): Promise<boolean> {
    if (!this.bot) {
      return false;
    }

    try {
      const chat = await this.bot.getChat(chatId);
      return !!chat;
    } catch (error) {
      return false;
    }
  }
}

export const telegramService = new TelegramService();

